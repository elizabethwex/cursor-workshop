---
import "../styles/global.css";
import Scanlines from "../components/Scanlines.astro";
import MatrixHeader from "../components/MatrixHeader.astro";

interface Props {
  title: string;
  description?: string;
}

const { title, description = "Cursor Workshop module." } = Astro.props;
---

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    {description && <meta name="description" content={description} />}
    <title>{title} | Cursor Workshop</title>
    <script src="https://cdn.tailwindcss.com/3.4.17" is:inline></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="" />
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=VT323&display=swap" rel="stylesheet" />
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.min.js" is:inline></script>
    <style is:global>
      :root {
        --matrix-green: #00FF41;
        --matrix-dark: #008F11;
        --matrix-black: #0d0d0d;
      }

      /* Override workshop theme tokens for Matrix look on module pages */
      body {
        background-color: #000 !important;
        color: var(--matrix-green) !important;
        font-family: 'Share Tech Mono', monospace !important;
        overflow-x: hidden;
        cursor: text;
      }

      body {
        --color-bg: #000;
        --color-surface: #0d0d0d;
        --color-text: #00FF41;
        --color-text-muted: #008F11;
        --color-accent: #00FF41;
        --color-accent-hover: #00ff88;
        --color-border: #003B00;
        --glow-subtle: rgba(0, 255, 65, 0.35);
        --color-accent-soft: rgba(0, 255, 65, 0.08);
        --color-success: #00FF41;
        --color-badge: #00FF41;
        --font-sans: 'Share Tech Mono', monospace;
        --font-mono: 'VT323', monospace;
      }

      ::-webkit-scrollbar {
        width: 8px;
      }
      ::-webkit-scrollbar-track {
        background: #000;
        border-left: 1px solid var(--matrix-dark);
      }
      ::-webkit-scrollbar-thumb {
        background: var(--matrix-dark);
      }
      ::-webkit-scrollbar-thumb:hover {
        background: var(--matrix-green);
      }

      ::selection {
        background: var(--matrix-green);
        color: black;
        text-shadow: none;
      }

      .scanlines {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          to bottom,
          rgba(255,255,255,0),
          rgba(255,255,255,0) 50%,
          rgba(0,0,0,0.2) 50%,
          rgba(0,0,0,0.2)
        );
        background-size: 100% 4px;
        z-index: 50;
        pointer-events: none;
        opacity: 0.6;
      }

      .scanlines::before {
        content: " ";
        display: block;
        position: absolute;
        top: 0;
        left: 0;
        bottom: 0;
        right: 0;
        background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 255, 0, 0.06));
        z-index: 2;
        background-size: 100% 2px, 3px 100%;
        pointer-events: none;
      }

      .neon-text {
        text-shadow: 0 0 5px var(--matrix-green), 0 0 10px var(--matrix-green);
      }

      .matrix-border {
        box-shadow: 0 0 4px var(--matrix-green);
      }

      @keyframes glitch {
        0% { transform: translate(0); }
        20% { transform: translate(-2px, 2px); }
        40% { transform: translate(-2px, -2px); }
        60% { transform: translate(2px, 2px); }
        80% { transform: translate(2px, -2px); }
        100% { transform: translate(0); }
      }

      .glitch:hover {
        animation: glitch 0.3s cubic-bezier(.25, .46, .45, .94) both infinite;
        color: white;
        text-shadow: 2px 0 #00ff00, -2px 0 #ff0000;
      }

      .cursor-blink {
        display: inline-block;
        width: 10px;
        height: 1em;
        background-color: var(--matrix-green);
        animation: blink 1s step-end infinite;
        vertical-align: bottom;
      }

      @keyframes blink {
        0%, 100% { opacity: 1; }
        50% { opacity: 0; }
      }

      .matrix-btn {
        position: relative;
        background: transparent;
        border: 1px solid var(--matrix-green);
        color: var(--matrix-green);
        transition: all 0.3s ease;
        text-transform: uppercase;
        letter-spacing: 2px;
        overflow: hidden;
      }

      .matrix-btn:hover {
        background: var(--matrix-green);
        color: black;
        box-shadow: 0 0 15px var(--matrix-green);
        font-weight: bold;
      }

      .matrix-card {
        background: rgba(0, 20, 0, 0.7);
        border: 1px solid #003B00;
        transition: all 0.3s ease;
      }

      .matrix-card:hover {
        border-color: var(--matrix-green);
        box-shadow: 0 0 10px rgba(0, 255, 65, 0.2);
        transform: translateY(-2px);
      }

      .font-terminal {
        font-family: 'VT323', monospace;
      }
    </style>
  </head>
  <body class="min-h-screen flex flex-col relative">
    <Scanlines />
    <div class="relative z-10 w-full min-h-screen flex flex-col">
      <MatrixHeader />
      <main class="flex-grow w-full max-w-5xl mx-auto px-4 sm:px-6 lg:px-8 py-12">
        <slot />
      </main>
    </div>
    <script is:inline>
      function initLucide() {
        if (typeof lucide !== 'undefined' && lucide.createIcons) {
          lucide.createIcons();
        } else {
          setTimeout(initLucide, 50);
        }
      }
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initLucide);
      } else {
        initLucide();
      }
    </script>
    <script>
      (function () {
        const VISITED_KEY = "cursor-workshop-visited-steps";

        function getVisited() {
          try {
            const raw = localStorage.getItem(VISITED_KEY);
            return raw ? JSON.parse(raw) : [];
          } catch {
            return [];
          }
        }

        function setVisited(paths) {
          try {
            localStorage.setItem(VISITED_KEY, JSON.stringify(paths));
          } catch (_) {}
        }

        const pathname = window.location.pathname.replace(/\/$/, "") || "/cursor-workshop";
        const visited = getVisited();
        if (!visited.includes(pathname)) {
          visited.push(pathname);
          setVisited(visited);
        }
      })();
    </script>
    <script define:vars={{ base: import.meta.env.BASE_URL }}>
      (function () {
        function isTextInput(el) {
          if (!el || !(el instanceof HTMLElement)) return false;
          const tag = el.tagName.toLowerCase();
          if (tag === "input" || tag === "textarea") return true;
          return el.isContentEditable === true;
        }

        document.addEventListener("keydown", function (e) {
          if (e.key !== "r" && e.key !== "R") return;
          if (e.ctrlKey || e.metaKey || e.altKey) return;
          if (isTextInput(e.target)) return;
          e.preventDefault();
          window.location.href = base;
        });
      })();
    </script>
  </body>
</html>
